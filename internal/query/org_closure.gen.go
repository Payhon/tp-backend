// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"project/internal/model"
)

func newOrgClosure(db *gorm.DB, opts ...gen.DOOption) orgClosure {
	_orgClosure := orgClosure{}

	_orgClosure.orgClosureDo.UseDB(db, opts...)
	_orgClosure.orgClosureDo.UseModel(&model.OrgClosure{})

	tableName := _orgClosure.orgClosureDo.TableName()
	_orgClosure.ALL = field.NewAsterisk(tableName)
	_orgClosure.TenantID = field.NewString(tableName, "tenant_id")
	_orgClosure.AncestorID = field.NewString(tableName, "ancestor_id")
	_orgClosure.DescendantID = field.NewString(tableName, "descendant_id")
	_orgClosure.Depth = field.NewInt(tableName, "depth")

	_orgClosure.fillFieldMap()

	return _orgClosure
}

type orgClosure struct {
	orgClosureDo

	ALL          field.Asterisk
	TenantID     field.String // 租户ID
	AncestorID   field.String // 祖先组织ID
	DescendantID field.String // 后代组织ID
	Depth        field.Int    // 层级深度

	fieldMap map[string]field.Expr
}

func (o orgClosure) Table(newTableName string) *orgClosure {
	o.orgClosureDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o orgClosure) As(alias string) *orgClosure {
	o.orgClosureDo.DO = *(o.orgClosureDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *orgClosure) updateTableName(table string) *orgClosure {
	o.ALL = field.NewAsterisk(table)
	o.TenantID = field.NewString(table, "tenant_id")
	o.AncestorID = field.NewString(table, "ancestor_id")
	o.DescendantID = field.NewString(table, "descendant_id")
	o.Depth = field.NewInt(table, "depth")

	o.fillFieldMap()

	return o
}

func (o *orgClosure) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *orgClosure) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 4)
	o.fieldMap["tenant_id"] = o.TenantID
	o.fieldMap["ancestor_id"] = o.AncestorID
	o.fieldMap["descendant_id"] = o.DescendantID
	o.fieldMap["depth"] = o.Depth
}

func (o orgClosure) clone(db *gorm.DB) orgClosure {
	o.orgClosureDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o orgClosure) replaceDB(db *gorm.DB) orgClosure {
	o.orgClosureDo.ReplaceDB(db)
	return o
}

type orgClosureDo struct{ gen.DO }

type IOrgClosureDo interface {
	gen.SubQuery
	Debug() IOrgClosureDo
	WithContext(ctx context.Context) IOrgClosureDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOrgClosureDo
	WriteDB() IOrgClosureDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOrgClosureDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOrgClosureDo
	Not(conds ...gen.Condition) IOrgClosureDo
	Or(conds ...gen.Condition) IOrgClosureDo
	Select(conds ...field.Expr) IOrgClosureDo
	Where(conds ...gen.Condition) IOrgClosureDo
	Order(conds ...field.Expr) IOrgClosureDo
	Distinct(cols ...field.Expr) IOrgClosureDo
	Omit(cols ...field.Expr) IOrgClosureDo
	Join(table schema.Tabler, on ...field.Expr) IOrgClosureDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOrgClosureDo
	RightJoin(table schema.Tabler, on ...field.Expr) IOrgClosureDo
	Group(cols ...field.Expr) IOrgClosureDo
	Having(conds ...gen.Condition) IOrgClosureDo
	Limit(limit int) IOrgClosureDo
	Offset(offset int) IOrgClosureDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOrgClosureDo
	Unscoped() IOrgClosureDo
	Create(values ...*model.OrgClosure) error
	CreateInBatches(values []*model.OrgClosure, batchSize int) error
	Save(values ...*model.OrgClosure) error
	First() (*model.OrgClosure, error)
	Take() (*model.OrgClosure, error)
	Last() (*model.OrgClosure, error)
	Find() ([]*model.OrgClosure, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OrgClosure, err error)
	FindInBatches(result *[]*model.OrgClosure, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.OrgClosure) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOrgClosureDo
	Assign(attrs ...field.AssignExpr) IOrgClosureDo
	Joins(fields ...field.RelationField) IOrgClosureDo
	Preload(fields ...field.RelationField) IOrgClosureDo
	FirstOrInit() (*model.OrgClosure, error)
	FirstOrCreate() (*model.OrgClosure, error)
	FindByPage(offset int, limit int) (result []*model.OrgClosure, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOrgClosureDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o orgClosureDo) Debug() IOrgClosureDo {
	return o.withDO(o.DO.Debug())
}

func (o orgClosureDo) WithContext(ctx context.Context) IOrgClosureDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o orgClosureDo) ReadDB() IOrgClosureDo {
	return o.Clauses(dbresolver.Read)
}

func (o orgClosureDo) WriteDB() IOrgClosureDo {
	return o.Clauses(dbresolver.Write)
}

func (o orgClosureDo) Session(config *gorm.Session) IOrgClosureDo {
	return o.withDO(o.DO.Session(config))
}

func (o orgClosureDo) Clauses(conds ...clause.Expression) IOrgClosureDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o orgClosureDo) Returning(value interface{}, columns ...string) IOrgClosureDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o orgClosureDo) Not(conds ...gen.Condition) IOrgClosureDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o orgClosureDo) Or(conds ...gen.Condition) IOrgClosureDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o orgClosureDo) Select(conds ...field.Expr) IOrgClosureDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o orgClosureDo) Where(conds ...gen.Condition) IOrgClosureDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o orgClosureDo) Order(conds ...field.Expr) IOrgClosureDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o orgClosureDo) Distinct(cols ...field.Expr) IOrgClosureDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o orgClosureDo) Omit(cols ...field.Expr) IOrgClosureDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o orgClosureDo) Join(table schema.Tabler, on ...field.Expr) IOrgClosureDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o orgClosureDo) LeftJoin(table schema.Tabler, on ...field.Expr) IOrgClosureDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o orgClosureDo) RightJoin(table schema.Tabler, on ...field.Expr) IOrgClosureDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o orgClosureDo) Group(cols ...field.Expr) IOrgClosureDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o orgClosureDo) Having(conds ...gen.Condition) IOrgClosureDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o orgClosureDo) Limit(limit int) IOrgClosureDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o orgClosureDo) Offset(offset int) IOrgClosureDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o orgClosureDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOrgClosureDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o orgClosureDo) Unscoped() IOrgClosureDo {
	return o.withDO(o.DO.Unscoped())
}

func (o orgClosureDo) Create(values ...*model.OrgClosure) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o orgClosureDo) CreateInBatches(values []*model.OrgClosure, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o orgClosureDo) Save(values ...*model.OrgClosure) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o orgClosureDo) First() (*model.OrgClosure, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.OrgClosure), nil
	}
}

func (o orgClosureDo) Take() (*model.OrgClosure, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.OrgClosure), nil
	}
}

func (o orgClosureDo) Last() (*model.OrgClosure, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.OrgClosure), nil
	}
}

func (o orgClosureDo) Find() ([]*model.OrgClosure, error) {
	result, err := o.DO.Find()
	return result.([]*model.OrgClosure), err
}

func (o orgClosureDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.OrgClosure, err error) {
	buf := make([]*model.OrgClosure, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o orgClosureDo) FindInBatches(result *[]*model.OrgClosure, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o orgClosureDo) Attrs(attrs ...field.AssignExpr) IOrgClosureDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o orgClosureDo) Assign(attrs ...field.AssignExpr) IOrgClosureDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o orgClosureDo) Joins(fields ...field.RelationField) IOrgClosureDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o orgClosureDo) Preload(fields ...field.RelationField) IOrgClosureDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o orgClosureDo) FirstOrInit() (*model.OrgClosure, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.OrgClosure), nil
	}
}

func (o orgClosureDo) FirstOrCreate() (*model.OrgClosure, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.OrgClosure), nil
	}
}

func (o orgClosureDo) FindByPage(offset int, limit int) (result []*model.OrgClosure, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o orgClosureDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o orgClosureDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o orgClosureDo) Delete(models ...*model.OrgClosure) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *orgClosureDo) withDO(do gen.Dao) *orgClosureDo {
	o.DO = *do.(*gen.DO)
	return o
}
